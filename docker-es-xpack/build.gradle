import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import java.nio.file.Files
import java.nio.file.Paths
import org.apache.tools.ant.filters.FixCrLfFilter

project.ext {
    elasticHost = project.buildEnv == 'WIN_DEV' ? project.devDockerHost : (System.env.ELASTIC_HOST ?: 'localhost')
    elasticPort = System.env.ELASTIC_PORT ?: '9200'
    elasticUser = System.env.XPACK_USER ?: 'elastic'
    elasticPassword = System.env.XPACK_PASSWORD ?: 'changeme'
    elasticBaseUrl = "http://${project.elasticHost}:${project.elasticPort}"
}

def targetDockerHubRepository = 'elasticsearch_xpack_data'
def dockerImageName = targetDockerHubOrganization + '/' + targetDockerHubRepository // like 'cwds/elasticsearch_xpack_data'
def dockerContainerName = targetDockerHubOrganization + '-' + targetDockerHubRepository + '-' + projectVersion
def dockerTag = projectVersion
def dockerContextDir = "$project.parent.buildDir/$project.name"

def esExecute(String method, String path, String content) {
    URL url = new URL(project.elasticBaseUrl + path)
    HttpURLConnection connection = (HttpURLConnection) url.openConnection()
    connection.setDoInput(true)
    connection.setDoOutput(true)
    connection.setRequestMethod(method)
    String authString = project.elasticUser + ":" + project.elasticPassword
    String authStringEnc = authString.bytes.encodeBase64().toString()
    connection.setRequestProperty("Authorization", "Basic " + authStringEnc);
    connection.setRequestProperty("Content-Type", "application/json")

    if (content != null) {
        OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream(), "UTF8")
        writer.write(content);
        writer.close();
    }

    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF8"));
    StringBuilder jsonString = new StringBuilder();
    String line
    while ((line = reader.readLine()) != null) {
        jsonString.append(line)
    }
    print jsonString
    int responseCode = connection.getResponseCode()
    connection.disconnect()
    return responseCode
}

void esConnect(baseUrl) {
    int responseCode = 0
    while (true) {
        try {
            responseCode = esExecute("GET", "/_xpack/security/role", null)
        } catch (Exception e) {
            //continue
        }
        if (responseCode == 200) {
            break
        }
        println "\nretrying to connect to " + baseUrl + " ... "
        sleep(7500)
    }
}

task dockerCleanUpLatest(type: Exec, dependsOn: project.parent.checkDockerService) {
    ignoreExitValue true
    environment << project.dockerEnvVars
    doFirst {
        commandLine 'docker', 'rmi', '--force', "$dockerImageName:latest"
    }
}

task dockerCleanUpTagged(type: Exec, dependsOn: project.parent.checkDockerService) {
    ignoreExitValue true
    environment << project.dockerEnvVars
    doFirst {
        commandLine 'docker', 'rmi', '--force', "$dockerImageName:$dockerTag"
    }
}

task dockerCleanUp (dependsOn: [dockerCleanUpLatest, dockerCleanUpTagged]) {}

task dockerRemoveContainer(type: Exec, dependsOn: project.parent.checkDockerService) {
    ignoreExitValue true
    environment << project.dockerEnvVars
    doFirst {
        commandLine 'docker', 'rm', '-v', '--force', dockerContainerName
    }
}

task dockerCopyScripts(type: Copy) {
    from projectDir
    into dockerContextDir
    include 'entrypoint.sh'
    include 'elasticsearch.yml'
    include 'jvm.options'
    filter(FixCrLfFilter.class, eol:FixCrLfFilter.CrLf.newInstance("lf"))
}

task dockerCopyXpackPerryRealm(type: Copy, dependsOn: ':x-pack-perry-realm:buildZip') {
    from "$project.parent.projectDir/x-pack-perry-realm/build/distributions"
    into dockerContextDir
    include "x-pack-perry-realm-${projectVersion}.zip"
    rename { file -> 'x-pack-perry-realm.zip' }
}

task dockerfile(type: Copy) {
    from file("$projectDir/Dockerfile")
    into dockerContextDir
}

task dockerCreateImage(type: Exec, dependsOn: [project.parent.checkDockerService, dockerRemoveContainer, dockerCleanUp, dockerCopyScripts, dockerCopyXpackPerryRealm, dockerfile]) {
    environment << project.dockerEnvVars
    doFirst {
        commandLine 'docker', 'build', '-t', dockerImageName, '-f', "$dockerContextDir/Dockerfile",
                '--build-arg', "ELASTICSEARCH_VERSION=$project.elasticsearchVersion", dockerContextDir
    }
    dockerRemoveContainer.mustRunAfter(project.parent.checkDockerService)
    dockerCleanUp.mustRunAfter(dockerRemoveContainer)
}

task dockerStartContainer(type: Exec, dependsOn: [project.parent.checkDockerService, dockerCreateImage]) {
    environment << project.dockerEnvVars
    doFirst {
        commandLine 'docker', 'run', '-d', "--name=$dockerContainerName", '-p', "$project.elasticPort:9200", '-e', "TOKEN_VALIDATION_URL=https://web.dev.cwds.io/perry/authn/validate?token=", '-e', "http.host=0.0.0.0", '-e', "transport.host=127.0.0.1", dockerImageName
    }
    doLast {
        esConnect(project.elasticBaseUrl)
    }
    dockerCreateImage.mustRunAfter(project.parent.checkDockerService)
}

static def readFile(String path) {
    return new String(Files.readAllBytes(Paths.get(path)))
}

task dockerPopulateXpackPolicies {
    doFirst {
        new JsonSlurper().parseText(readFile("$projectDir/xpack_policies.json")).each {
            String[] action = it.action.toString().split("\\s")
            String content = it.content == null ? null : JsonOutput.toJson(it.content)
            esExecute(action[0], action[1], content)
        }
    }
}

task dockerPopulateTestPeople {
    enabled = (System.getProperty("es.populate.test.people") ?: 'true').equalsIgnoreCase('true')
    doFirst {
        // create people index
        esExecute("PUT", "/people", "{}")
        // create people-summary index
        esExecute("PUT", "/people-summary", "{}")
        // create facilities index
        esExecute("PUT", "/facilities", "{}")
        // create screenings index
        esExecute("PUT", "/screenings", "{}")
    }
    doLast {
        // populate test people data
        ["R", "S", "N", "NR", "NS", "R_county_n", "int", "cases"].each {
            String esUrl = "/people/person/person_$it"
            String content = readFile("$projectDir/test_data/people/person_${it}.json")
            esExecute("PUT", esUrl, content)
        }
        // verify with URL like: http://192.168.99.100:9200/people/person/_search?pretty
        ["R", "S", "N"].each {
            String esUrl = "/people-summary/person-summary/person_summary_$it"
            String content = readFile("$projectDir/test_data/people-summary/person_summary_${it}.json")
            esExecute("PUT", esUrl, content)
        }
        // verify with URL like: http://192.168.99.100:9200/people-summary/person-summary/_search?pretty

        String esFacilitiesUrl = "/facilities/facility/facility1"
        String facilityContent = readFile("$projectDir/test_data/facilities/facility.json")
        esExecute("PUT", esFacilitiesUrl, facilityContent)

        String esScreeningsUrl = "/screenings/screening/screening1"
        String screeningContent = readFile("$projectDir/test_data/screenings/screening.json")
        esExecute("PUT", esScreeningsUrl, screeningContent)
    }
}

task dockerCommitPopulatedImage(type: Exec, dependsOn: [project.parent.checkDockerService, dockerStartContainer, dockerPopulateXpackPolicies, dockerPopulateTestPeople]) {
    environment << project.dockerEnvVars
    doFirst {
        commandLine 'docker', 'commit', '-m', 'populated', dockerContainerName, dockerImageName
    }
    dockerStartContainer.mustRunAfter(project.parent.checkDockerService)
    dockerPopulateXpackPolicies.mustRunAfter(dockerStartContainer)
    dockerPopulateTestPeople.mustRunAfter(dockerStartContainer)
}

task dockerStopContainer(type: Exec, dependsOn: project.parent.checkDockerService) {
    environment << project.dockerEnvVars
    doFirst {
        commandLine 'docker', 'stop', dockerContainerName
    }
}

task dockerTagImage(type: Exec, dependsOn: project.parent.checkDockerService) {
    environment << project.dockerEnvVars
    doFirst {
        commandLine 'docker', 'tag', dockerImageName, "$dockerImageName:$dockerTag"
    }
}

task dockerPushTaggedVersion(type: Exec, dependsOn: [project.parent.checkDockerService, dockerTagImage]) {
    environment << project.dockerEnvVars
    doFirst {
        commandLine 'docker', 'push', "$dockerImageName:$dockerTag"
    }
    dockerTagImage.mustRunAfter(project.parent.checkDockerService)
}

task dockerPushLatestVersion(type: Exec, dependsOn: project.parent.checkDockerService) {
    environment << project.dockerEnvVars
    doFirst {
        commandLine 'docker', 'push', "$dockerImageName:latest"
    }
}

task dockerEsXpackPublish(dependsOn: [dockerCommitPopulatedImage, dockerStopContainer, dockerPushTaggedVersion, dockerPushLatestVersion]) {
    doLast {
        println '\nElasricsearch + X-Pack docker image is published'
    }
    dockerStopContainer.mustRunAfter(dockerCommitPopulatedImage)
    dockerPushTaggedVersion.mustRunAfter(dockerStopContainer)
    dockerPushLatestVersion.mustRunAfter(dockerStopContainer)
}
